#!/usr/bin/env python
# Copyright (c) 2005-2006 XenSource, Inc. All use and distribution of this 
# copyrighted material is governed by and subject to terms and conditions 
# as licensed by XenSource, Inc. All other rights reserved.
# Xen, XenSource and XenEnterprise are either registered trademarks or 
# trademarks of XenSource Inc. in the United States and/or other countries.

###
# XEN CLEAN INSTALLER
# Boot script
#
# written by Mark Nijmeijer and Andrew Peace

import commands
import sys
import os
import os.path

# user interface:
import tui
import tui.init
import tui.progress
import generalui

import install
import product
import init_constants
import xelogging
import netutil
import util
import hardware
import restore
from hardware import module_map
import driver
import p2v

from version import *
from constants import EXIT_OK, EXIT_ERROR, EXIT_USER_CANCEL

base_modules = ['sd-mod', 'sr-mod', 'dm-mod', 'ide-cd', 'ide-disk',
                'ide-generic', 'loop', 'ata_piix', 'rtc', 'reiserfs',
                'ext3', 'usb-storage']

# Use the 'discover' tool to detect hardware and load needed
# modules;
#
# This has turned into a bit of a hack.  The 'hwdetect' script
# uses information directly from the kernel build to find hardware
# (i.e. modules.pcimap), but I don't entirely understand where
# these come from or if they're complete.
def discoverHardware():
    _, out1 = commands.getstatusoutput("discover --enable-all --module ide")
    _, out2 = commands.getstatusoutput("discover --enable-all --module scsi")
    _, out3 = commands.getstatusoutput("discover --enable-all --module all")
    _, out4 = commands.getstatusoutput("/opt/xensource/installer/hwdetect")
    out = out1 + "\n" + out2 + "\n" + out3 + "\n" + out4
    out = out.split("\n")
    
    modules = []
    for m in out:
        if m not in modules and m != "":
            modules.append(m)
    modules = [x.replace('_', '-') for x in modules]

    # make a list of modules to load:
    rv = []
    for mod in modules:
        if module_map.has_key(mod):
            if module_map[mod] == []:
                xelogging.log("Ignoring module %s" % mod)
            else:
                xelogging.log("Discover found %s - we think we need %s" % (mod, module_map[mod]))
                for mymod in module_map[mod]:
                    if not mymod in rv:
                        rv.append(mymod)
        else:
            xelogging.log("Discover found %s" % mod)
            rv.append(mod)
    
    xelogging.log("Hardware discovery complete.")
    return rv

def configureHardware(extra_modules, blacklist, ui, interactive):
    """Detect and configure hardware"""

    assert not interactive or (interactive and ui)

    if ui:
        pd = ui.progress.initProgressDialog(
            "Preparing for Installation",
            "Your system hardware is being detected and configured...",
            100
            )
        ui.progress.displayProgressDialog(0, pd)
    
    modules = discoverHardware()
    modules.extend(base_modules)
    modules.extend(extra_modules)

    # load the modules:
    current = 0
    for m in modules:
        if m in blacklist:
            xelogging.log("Module %s was in the user-specified blacklist - not loading." % m)
        else:
            load_m = True
            if interactive and ui != None:
                load_m = ui.init.ask_load_module(m)
            if load_m:
                hardware.modprobe(m)
                current = current + 1
                current_scaled = int( float(current) / float(len(modules)) * 100.0 )
                if ui:
                    ui.progress.displayProgressDialog(current_scaled, pd)
    
    # if we're in an older (pre udev-091) filesystem, we need
    # to call udevstart as udevd wasn't working correctly:
    #if os.path.exists("/sbin/udevstart"):
    #    os.system("udevstart")

    # we should wait for all udev events to complete if we have
    # that capability:
    if os.path.exists("/sbin/udevsettle"):
        os.system("udevsettle --timeout=10")

    if ui:
        ui.progress.clearModelessDialog()

# Attempt to configure the network:
def configureNetworking(ui):
    if ui:
        ui.progress.showMessageDialog(
            "Preparing for installation",
            "Attempting to configure networking..."
            )

    nethw = netutil.scanConfiguration()
    netcfg = {}
    for i in nethw.keys():
        netcfg[i] = netutil.mk_iface_config_dhcp(nethw[i].hwaddr, True)

    netutil.writeDebStyleInterfaceFile(netcfg, '/etc/network/interfaces')

    for i in nethw.keys():
        netutil.ifup(i)

    if ui:
        ui.progress.clearModelessDialog()

def main(args):
    # switch to ISO 8859-1 mode so line drawing characters work as expected on 
    # vt100 terminals.
    print "\033%@"

    # log to tty3
    xelogging.openLog('/dev/tty3')

    operation = None
    ui = tui
    extra_modules = []
    user_blacklist = []
    interactive_modules = False
    interactive = True
    driver_repos = []

    for (opt, val) in args.items():
        if opt == "--install":
            operation = init_constants.OPERATION_INSTALL
        elif opt == "--p2v":
            operation = init_constants.OPERATION_P2V
        elif opt == '--interactive-modules':
            interactive_modules = True
        elif opt == "--answerfile":
            interactive = False
        elif opt == "--rt_answerfile":
            interactive = False
            ui = None
            xelogging.openLog(sys.stdout)
        elif opt == "--extramodules":
            extra_modules = val.split(",")
        elif opt == "--blacklist":
            user_blacklist = val.split(",")

    # check that an answerfile was specified if we're being non-interactive:
    if not interactive and not operation:
        xelogging.log("No operation specified for answerfile - dropping back to interactive mode.")
        interactive = True
        ui = tui

    # start the user interface:
    if ui:
        xelogging.log("Starting 'init' user interface")
        ui.init_ui()

    # first, configure the hardware, make /etc/network and /lib/firmware, etc.:
    util.assertDir('/lib/firmware')
    util.assertDir('/var/lib')
    util.assertDir('/var/run')
    util.assertDir('/var/lock')
    configureHardware(extra_modules, user_blacklist,
                      ui, interactive_modules)

    # let the user choose what they would like to do:
    if interactive:
        # choose keymap
        kmap = ui.init.get_keymap()
        args['--keymap'] = kmap
        xelogging.log("Loading keymap %s" % kmap)
        util.runCmd2(["/bin/loadkeys", kmap])

        xelogging.writeLog("/tmp/startup-log")
    else:
        configureNetworking(ui)

    backups = product.findXenSourceBackups()
    try:
        while True:
            # if interactive, set the operation:
            if interactive and not operation:
                operation = ui.init.choose_operation(len(backups) > 0)

            if operation == init_constants.OPERATION_REBOOT:
                break

            # install/upgrade:
            elif operation == init_constants.OPERATION_INSTALL:
                xelogging.log("Starting installation/upgrade")

                args['--extrarepo'] = driver_repos
                rc = install.go(ui, args)

            # load a driver:
            elif operation == init_constants.OPERATION_LOAD_DRIVER:
                driver_repos.extend(driver.doInteractiveLoadDriver(ui))
                rc = None

            # restore:
            elif operation == init_constants.OPERATION_RESTORE:
                xelogging.log("Starting restore")
                rc = restore.go(ui)

            # P2V:
            elif operation == init_constants.OPERATION_P2V:
                xelogging.log("Starting P2V")
                rc = p2v.go(args, ui)

            operation = None
            # if we're non-interactive, or weren't canceled, force us to exit:
            if rc == EXIT_OK or rc == EXIT_ERROR or not interactive:
                break

    finally:
        if ui:
            ui.end_ui()

        # stop logging to tty3:
        xelogging.closeLogs()

    try:
        if os.readlink('/proc/self/fd/0') != '/dev/console':
            print "Not on the console, not rebooting"
            return False
    except:
        pass
    return True


if __name__ == "__main__":
    reboot = main(util.splitArgs(sys.argv[1:]))
    if reboot:
        os.system("reboot")
