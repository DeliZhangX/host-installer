#!/usr/bin/env python
# Copyright (c) 2005-2006 XenSource, Inc. All use and distribution of this 
# copyrighted material is governed by and subject to terms and conditions 
# as licensed by XenSource, Inc. All other rights reserved.
# Xen, XenSource and XenEnterprise are either registered trademarks or 
# trademarks of XenSource Inc. in the United States and/or other countries.

###
# XEN CLEAN INSTALLER
# Boot script
#
# written by Mark Nijmeijer and Andrew Peace

import commands
import sys
import os
import os.path
from getopt import getopt, GetoptError
import shutil
import time

# user interface:
import tui
import tui.init
import tui.progress
import generalui

import product
import diskutil
import init_constants
import xelogging
import netutil
import util
import hardware
import repository
import tempfile
import restore
from hardware import module_map

from version import *
from constants import EXIT_OK, EXIT_ERROR, EXIT_USER_CANCEL

base_modules = ['sd-mod',
                'sr-mod',
                'dm-mod',
                'ide-cd',
                'ide-disk',
                'ide-generic',
                'loop',
                'ata_piix',
                'rtc',
                'reiserfs',
                'ext3',
		'usb-storage']

active_output = 'tty1'

# Exception that is thrown if we detect that the user has
# tried to use two consoles to perform an installation
class AlreadyActivated(Exception):
    pass

# Specify the current console as the one that is to be used
# for installation - after this is called the user will be
# given an error message if they try to run the installer on
# a different console.
def activateScreen():
    lock_filename = "/tmp/.install-activated"
    if os.path.exists(lock_filename):
        rc, tty = commands.getstatusoutput("/usr/bin/tty")
        assert rc == 0
        activefile = open(lock_filename, 'r')
        active_tty = activefile.readline().strip()
        activefile.close()
        if active_tty != tty:
            raise AlreadyActivated()
    else:
        rc, tty = commands.getstatusoutput("/usr/bin/tty")
        assert rc == 0
        activefile = open(lock_filename, 'w')
        activefile.write(tty)
        activefile.close()

def doInteractiveLoadDriver(ui):
    rc = ui.init.driver_disk_sequence()
    if rc:
        media, address = rc
        repos = repository.repositoriesFromDefinition(media, address)
        drivers = []
        pkglines = []

        # put firmware in place:
        for r in repos:
            for p in r:
                if p.type == 'firmware':
                    p.provision()

        # now load the drivers:
        drivers = []
        driver_repos = []
        for r in repos:
            r.accessor().start()
            repo_has_drivers = False
            for p in r:
                if p.type == 'driver':
                    repo_has_drivers = True
                    _, driver_file = tempfile.mkstemp(prefix="driver-", dir="/tmp")
                    p.write(driver_file)
                    drivers.append( (p.name, driver_file) )
                elif p.type == 'firmware':
                    repo_has_drivers = True
            r.accessor().finish()

            if repo_has_drivers:
                driver_repos.append(r)
                driver_has_repos = False

        total_rc = 0
        for name, driver in drivers:
            rc = hardware.modprobe_file(driver, name = name)
            total_rc += rc
        if total_rc != 0:
            ui.OKDialog("Error", "One or more of your drivers failed to load.")

        # stash the repositories we used for pickup later:
        dr_copies = []
        for dr in driver_repos:
            loc = tempfile.mkdtemp(prefix="stashed-repo-", dir="/tmp")
            dr.accessor().start()
            dr.copyTo(loc)
            dr.accessor().finish()
            dr_copies.append(loc)
        return dr_copies
    else:
        return []

# Use the 'discover' tool to detect hardware and load needed
# modules;
#
# This has turned into a bit of a hack.  The 'hwdetect' script
# uses information directly from the kernel build to find hardware
# (i.e. modules.pcimap), but I don't entirely understand where
# these come from or oif they're complete.
def discoverHardware():
    rc1, out1 = commands.getstatusoutput("discover --enable-all --module ide")
    rc2, out2 = commands.getstatusoutput("discover --enable-all --module scsi")
    rc3, out3 = commands.getstatusoutput("discover --enable-all --module all")
    rc4, out4 = commands.getstatusoutput("/opt/xensource/installer/hwdetect")
    out = out1 + "\n" + out2 + "\n" + out3 + "\n" + out4
    out = out.split("\n")
    
    modules = []
    for m in out:
        if m not in modules and m != "":
            modules.append(m)
    modules = [x.replace('_', '-') for x in modules]

    # make a list of modules to load:
    rv = []
    for mod in modules:
        if module_map.has_key(mod):
            if module_map[mod] == []:
                xelogging.log("Ignoring module %s" % mod)
            else:
                xelogging.log("Discover found %s - we think we need %s" % (mod, module_map[mod]))
                for mymod in module_map[mod]:
                    if not mymod in rv:
                        rv.append(mymod)
        else:
            xelogging.log("Discover found %s" % mod)
            rv.append(mod)
    
    xelogging.log("Hardware disocvery complete.")
    return rv


def configureHardware(extra_modules = [],
                      blacklist = [],
                      ui = None,
                      interactive = False):
    """Detect and configure hardware"""

    assert not interactive or (interactive and ui)

    if ui:
        pd = ui.progress.initProgressDialog(
            "Preparing for Installation",
            "Your system hardware is being detected and configured...",
            100
            )
        ui.progress.displayProgressDialog(0, pd)
    
    modules = discoverHardware()
    modules.extend(base_modules)
    modules.extend(extra_modules)

    # load the modules:
    current = 0
    for m in modules:
        if m in blacklist:
            xelogging.log("Module %s was in the user-specified blacklist - not loading." % m)
        else:
            load_m = True
            if interactive and ui != None:
                load_m = ui.ask_load_module(m)
            if load_m:
                hardware.modprobe(m)
                current = current + 1
                current_scaled = int( float(current) / float(len(modules)) * 100.0 )
                if ui:
                    ui.progress.displayProgressDialog(current_scaled, pd)
    
    # if we're in an older (pre udev-091) filesystem, we need
    # to call udevstart as udevd wasn't working correctly:
    if os.path.exists("/sbin/udevstart"):
        os.system("udevstart")

    # we should wait for all udev events to complete if we have
    # that capability:
    if os.path.exists("/sbin/udevsettle"):
        os.system("udevsettle --timeout=10")

    assert os.system("touch %s" % init_constants.HW_CONFIG_COMPLETED_STAMP) == 0

    if ui:
        ui.progress.clearModelessDialog()

# Attempt to configure the network:
def configureNetworking(ui):
    if ui:
        ui.progress.showMessageDialog(
            "Preparing for installation",
            "Attempting to configure networking..."
            )

    interfaces = netutil.getNetifList()
    netcfg = {}
    for i in interfaces:
        netcfg[i] = { 'use-dhcp': True , 'enabled': True }

    netutil.writeDebStyleInterfaceFile(netcfg, '/etc/network/interfaces')

    for i in interfaces:
        netutil.ifup(i)

    if ui:
        ui.progress.clearModelessDialog()

def isPrimaryProcess():
    """ Returns True if we can expect the user to provide input on the
    tty that we're currently running on. """
    rc, my_tty = commands.getstatusoutput("tty")
    my_tty = os.path.basename(my_tty.strip('\n'))
    return my_tty == active_output

def main():
    global active_output

    # switch to ISO 8859-1 mode so line drawing characters work as expected on 
    # vt100 terminals.
    print "\033%@"

    # clog fds: add tty3
    clog_fds = []
    try:
        ttylog = open('/dev/tty3', 'w')
        clog_fds.append(ttylog)
        xelogging.continuous_logs.append(ttylog)
    except:
        xelogging.log("Error opening tty3 as a log output.")

    # disable all kernel printing
    pk = open('/proc/sys/kernel/printk', 'w')
    pk.write('1')
    pk.close()

    # mount all fstab filesystems if they're not already mounted:
    if os.system("grep -q 'sysfs' /proc/mounts") != 0:
        util.runCmd('mount -t sysfs none /sys')

    # start portmap so NFS mounting works:
    util.runCmd('portmap')

    # parse options:
    try:
        (opts, _) = getopt(sys.argv[1:],
                           "",
                           ["install",
                            "upgrade",
                            "p2v",
                            "interactive-modules",
                            "answerfile=",
                            "verbose-answerfile=",
                            "modules=",
                            "blacklist=",
                            "output="])
    except GetoptError:
        print "Incorrect arguments."
        sys.exit(1)

    mode = init_constants.MODE_INTERACTIVE
    ui = tui
    extra_modules = []
    user_blacklist = []
    answerfile = None
    verbose_answerfile = None
    interactive_modules = False
    driver_repos = []

    for (opt, val) in opts:
        if opt == "--install":
            mode = init_constants.MODE_INSTALL
        if opt == "--upgrade":
            mode = init_constants.MODE_UPGRADE
        if opt == "--p2v":
            mode = init_constants.MODE_P2V
        if opt == '--interactive-modules':
            interactive_modules = True
        if opt == "--answerfile":
            answerfile = val
        if opt == "--verbose-answerfile":
            ui = None
            xelogging.continuous_logs.append(sys.stdout)
            verbose_answerfile = val
        if opt == "--modules":
            extra_modules = val.split(",")
        if opt == "--blacklist":
            user_blacklist = val.split(",")
        if opt == "--output":
            active_output = val

    xelogging.log("Active output is %s" % active_output)

    # check that an answerfile was specified if we're being non-interactive:
    if mode != init_constants.MODE_INTERACTIVE and not (answerfile or verbose_answerfile):
        xelogging.log("A non-interactive mode was selected, but no answerfile was specified.  Dropping back to interactive mode.")
        mode = init_constants.MODE_INTERACTIVE
        ui = tui

    # make /etc/network and /lib/firmware writeable,
    # setup LVM:
    if isPrimaryProcess():
        util.assertDir('/lib/firmware')
        util.assertDir('/var/lib')
        util.assertDir('/var/run')
        util.assertDir('/var/lock')

    # start the user interface:
    xelogging.log("Starting 'init' user interface")
    if ui:
        ui.init_ui()

    # first, configure the hardware:
    if isPrimaryProcess():
        configureHardware(extra_modules, user_blacklist,
                          ui, interactive_modules)
    else:
        if ui:
            ui.progress.showMessageDialog(
                "Preparing for installation",
                "Waiting for hardware detection to complete..."
                )
        while not os.path.exists(init_constants.HW_CONFIG_COMPLETED_STAMP):
            time.sleep(1)
        if ui:
            ui.progress.clearModelessDialog()

    # let the user choose what they would like to do:
    if mode == init_constants.MODE_INTERACTIVE:
        # choose keymap
        kmap = ui.init.get_keymap()
        xelogging.log("Loading keymap %s" % kmap)
        util.runCmd2(["/bin/loadkeys", kmap])

        if isPrimaryProcess():
            xelogging.writeLog("/tmp/startup-log")

        firstTime = True
        backups = product.findXenSourceBackups()
        try:
            while True:
                operation = ui.init.choose_operation(len(backups) > 0)

                # activate installation on this screen:
                try:
                    activateScreen()
                    if not isPrimaryProcess():
                        xelogging.log("WARNING: Operation started on a console different that the one specified as being default on the kernel command-line")
                except AlreadyActivated:
                    ui.init.already_activated()
                    break

                # reboot (process this action before hardware
                # detection to save the weirdness of detecting
                # hardware to then immediately reboot):
                if operation == -1:
                    break

                def exit_status_of_rc(rc):
                    return rc >> 8

                # clean install:
                if operation == init_constants.OPERATION_INSTALL:
                    xelogging.log("Starting clean installation")
                    driver_repo_string = " ".join(["--extrarepo %s" % d for d in driver_repos])
                    s = os.system("/opt/xensource/installer/clean-installer --clog /dev/tty3 --keymap %s %s " % (kmap, driver_repo_string))
                    rc = exit_status_of_rc(s)
                    if rc == EXIT_OK or rc == EXIT_ERROR: 
                        break
                    else:
                        pass

                # load a driver:
                elif operation == init_constants.OPERATION_LOAD_DRIVER:
                    driver_repos.extend(doInteractiveLoadDriver(ui))

                # restore
                elif operation == init_constants.OPERATION_RESTORE:
                    if not restore.interactiveRestore(ui):
                        xelogging.writeLog("/tmp/startup-log")
                        tui.progress.OKDialog("Error restoring from backup", "An error occurred when attempting to restore your backup.  Please consult the logs (available in /tmp) for more details.")
                    else:
                        break

                # P2V:
                elif operation == init_constants.OPERATION_P2V:
                    xelogging.log("Starting P2V")
                    s = os.system("/opt/xensource/installer/p2v.py --clog /dev/tty3")
                    rc = exit_status_of_rc(s)
                    if rc == EXIT_OK or rc == EXIT_ERROR:
                        break
                    else:
                        pass

        except Exception:
            ui.end_ui()
            raise

    # non-interactive:
    else:
        # terminate on any screen that wasn't supposed to be used:
        if isPrimaryProcess():
            activateScreen()
        else:
            if ui:
                ui.init.already_activated()
            sys.exit(0)

        configureNetworking(ui)

        if isPrimaryProcess():
            xelogging.writeLog("/tmp/startup-log")

        if mode == init_constants.MODE_INSTALL:
            if answerfile:
                os.system("/opt/xensource/installer/clean-installer --answerfile %s --clog /dev/tty3" % answerfile)
            elif verbose_answerfile:
                os.system("/opt/xensource/installer/clean-installer --verbose-answerfile %s" % verbose_answerfile)
            else:
                os.system("/opt/xensource/installer/clean-installer --clog /dev/tty3")
            os.system("reboot")

        elif mode == init_constants.MODE_UPGRADE:
            raise Exception, "Upgrade not supported in this mode."
                
        elif mode == init_constants.MODE_P2V:
            if answerfile:
                os.system("/opt/xensource/installer/p2v.py --answerfile %s --clog /dev/tty3" % answerfile)
            else:
                os.system("/opt/xensource/installer/p2v.py --clog /dev/tty3")
            os.system("reboot")

    # Everything finished - from here we just shut down and reboot

    if ui:
        ui.end_ui()

    if os.path.ismount('/etc/network'):
        util.umount('/etc/network')

    # stop logging to tty3:
    for logfd in clog_fds:
        try:
            xelogging.continuous_logs.remove(logfd)
        except:
            pass
        logfd.close()

if __name__ == "__main__":
    main()
    os.system("reboot")
    
