#!/usr/bin/env python
# Copyright (c) 2005-2006 XenSource, Inc. All use and distribution of this 
# copyrighted material is governed by and subject to terms and conditions 
# as licensed by XenSource, Inc. All other rights reserved.
# Xen, XenSource and XenEnterprise are either registered trademarks or 
# trademarks of XenSource Inc. in the United States and/or other countries.

###
# XEN CLEAN INSTALLER
# Main script
#
# written by Andrew Peace

import os
import sys
import traceback

# user-interface stuff:
import tui.installer
import tui.installer.screens
import tui.progress
import util
import answerfile
import uicontroller
import constants

# hardware
import diskutil
import netutil
import hardware

# backend
import backend
import product
import upgrade

# general
import xelogging
from getopt import getopt, GetoptError

def main():
    ui = tui
    
    # disable all kernel printing
    util.runCmd("echo 1 > /proc/sys/kernel/printk")

    # sync hwclock to syscock ready for date/time stuff
    util.runCmd("hwclock --utc --hctosys")
    
    try:
        (opts, _) = getopt(sys.argv[1:],
                           "",
                           ["answerfile=",
                            "verbose-answerfile=",
                            "keymap=",
                            "clog=",
                            "onecd",
                            "extrarepo=",
                            "bootloader=",
                            "install-xen64"])
    except GetoptError:
        print "Invalid arguments."
        sys.exit(1)

    # prepare LVM - we need this very early now.
    os.environ['LVM_SYSTEM_DIR'] = '/tmp/lvm'
    if not os.path.exists('/tmp/lvm'):
        os.mkdir('/tmp/lvm')

    clog_fds = []
    extra_repo_defs = []
    results = {}
    answerfile_address = None
    suppress_extra_cd_dialog = False

    for (opt, val) in opts:
        if opt == "--keymap":
            results["keymap"] = val
            xelogging.log("Keymap specified on command-line: %s" % val)
        if opt == "--answerfile":
            answerfile_address = val
        if opt == "--verbose-answerfile":
            ui = None
            answerfile_address = val
            xelogging.continuous_logs.append(sys.stdout)
        if opt == "--clog":
            try:
                fd = open(val, "w")
                clog_fds.append(fd)
                xelogging.continuous_logs.append(fd)
            except:
                print "Error adding continuous log %s." % val
        if opt == "--extrarepo":
            if not os.path.isdir(val):
                raise RuntimeError, "Repository %s did not exist." % val
            else:
                extra_repo_defs.append(('filesystem', val))
        elif opt == "--bootloader":
            xelogging.log("Bootloader specified on command-line: %s" % val)
            if val == "grub":
                results['bootloader'] = constants.BOOTLOADER_TYPE_GRUB
            elif val == "extlinux":
                results['bootloader'] = constants.BOOTLOADER_TYPE_EXTLINUX
        elif opt == "--install-xen64":
            xelogging.log("Installing xen64 package")
            results['install-xen64'] = True
        elif opt == "--onecd":
            suppress_extra_cd_dialog = True
    try:
        # loading an answerfile?
        assert ui != None or answerfile_address != None

        xelogging.log("Starting user interface")
        if ui:
            ui.init_ui()

        if answerfile_address:
            results.update(answerfile.processAnswerfile(answerfile_address))

        results['extra-repos'] = extra_repo_defs

        # log the modules that we loaded:
        xelogging.log("All needed modules should now be loaded. We have loaded:")
        util.runCmd("lsmod")

        status = constants.EXIT_OK

        disks = diskutil.getQualifiedDiskList()
        nethw = netutil.scanConfiguration()        

        # make sure we have discovered at least one disk and
        # at least one network interface:
        if len(disks) == 0:
            raise RuntimeError, "No disks found on this host."

        if len(nethw.keys()) == 0:
            raise RuntimeError, "No network interfaces found on this host."

        # record the network configuration at startup so it remains consistent
        # in the face of kudzu:
        results['network-hardware'] = nethw

        # make sure that we have enough disk space:
        xelogging.log("Found disks: %s" % str(disks))
        diskSizes = [diskutil.getDiskDeviceSize(x) for x in disks]
        diskSizesGB = [diskutil.blockSizeToGBSize(x) for x in diskSizes]
        xelogging.log("Disk sizes: %s" % str(diskSizesGB))

        dom0disks = filter(lambda x: constants.min_primary_disk_size <= x <= constants.max_primary_disk_size,
                           diskSizesGB)
        if len(dom0disks) == 0:
            raise RuntimeError, "Unable to find a suitable disk (with a size between %dGB and %dGB) to install to." % (constants.min_primary_disk_size, constants.max_primary_disk_size)

        # how much RAM do we have?
        ram_found_mb = hardware.getHostTotalMemoryKB() / 1024
        ram_warning = ram_found_mb < constants.MIN_SYSTEM_RAM_MB
        vt_warning = not hardware.VTSupportEnabled()

        # find existing installations:
        if ui:
            ui.progress.showMessageDialog("Please wait", "Checking for existing products...")
        try:
            all_installed_products = product.findXenSourceProducts()
        except Exception, e:
            xelogging.log("A problem occurred whilst scanning for existing installations:")
            ex = sys.exc_info()
            err = str.join("", traceback.format_exception(*ex))
            xelogging.log(err)
            xelogging.log("This is not fatal.  Continuing anyway.")
            all_installed_products = []
        installed_products = filter(lambda p: upgrade.upgradeAvailable(p),
                                    all_installed_products)
        if ui:
            ui.progress.clearModelessDialog()
        
        # Generate the UI sequence and populate some default
        # values in backend input.  Note that not all these screens
        # will be displayed as they have conditional to skip them at
        # the start of each function.  In future these conditionals will
        # be moved into the sequence definition and evaluated by the
        # UI dispatcher.
        aborted = False
        if ui and not answerfile_address:
            uiexit = ui.installer.runMainSequence(
	            results, ram_warning, vt_warning, installed_products, suppress_extra_cd_dialog
                )
            if uiexit == uicontroller.EXIT:
                aborted = True

        if not aborted:
            xelogging.log("Starting actual installation")       
            backend.performInstallation(results, ui)

            if ui and not answerfile_address:
                ui.installer.screens.installation_complete()
            
            xelogging.log("The installation completed successfully.")
        else:
            xelogging.log("The user aborted the installation from within the user interface.")
            status = constants.EXIT_USER_CANCEL
    except Exception, e:
        # first thing to do is to get the traceback and log it:
        ex = sys.exc_info()
        err = str.join("", traceback.format_exception(*ex))
        xelogging.log("INSTALL FAILED.")
        xelogging.log("A fatal exception occurred:")
        xelogging.log(err)

        # now write out logs where possible:
        xelogging.writeLog("/tmp/install-log")

        # collect logs where possible
        xelogging.collectLogs("/tmp")

        # now display a friendly error dialog:
        if ui:
            ui.exn_error_dialog("install-log", True)
        else:
            txt = constants.error_string(str(e), 'install-log', True)
            xelogging.log(txt)

        # clean up the screen
        if ui:
            ui.end_ui()

        # and now on the disk if possible:
        if results.has_key('primary-disk'):
            backend.writeLog(results['primary-disk'])

        # close continuous logs:
        for logfd in clog_fds:
            try:
                xelogging.continuous_logs.remove(logfd)
            except:
                pass
            logfd.close()

        # exit with failure status:
        status = constants.EXIT_ERROR

    else:
        if ui:
            xelogging.log("Shutting down user interface")
            ui.end_ui()
        
        # close continuous logs:
        for logfd in clog_fds:
            try:
                xelogging.continuous_logs.remove(logfd)
            except:
                pass
            logfd.close()

        # put the log in /tmp:
        xelogging.writeLog("/tmp/install-log")
        xelogging.collectLogs('/tmp')

        # and now on the disk if possible:
        if results.has_key('primary-disk'):
            backend.writeLog(results['primary-disk'])

        assert (status == constants.EXIT_OK or status == constants.EXIT_USER_CANCEL)

    return status

if __name__ == "__main__":
    sys.exit(main())
