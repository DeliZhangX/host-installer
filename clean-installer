#!/usr/bin/env python
# Copyright (c) 2005-2006 XenSource, Inc. All use and distribution of this 
# copyrighted material is governed by and subject to terms and conditions 
# as licensed by XenSource, Inc. All other rights reserved.
# Xen, XenSource and XenEnterprise are either registered trademarks or 
# trademarks of XenSource Inc. in the United States and/or other countries.

###
# XEN CLEAN INSTALLER
# Main script
#
# written by Andrew Peace

import os
import sys
import traceback

# user-interface stuff:
import tui
import util
import answerfile_ui
import uicontroller
import constants
from version import COMPANY_NAME_SHORT

# hardware
import diskutil
import netutil
import hardware

# backend
import backend
import product
import upgrade

# general
import xelogging
from getopt import getopt, GetoptError

def main():
    ui_package = tui
    
    # disable all kernel printing
    util.runCmd("echo 1 > /proc/sys/kernel/printk")

    # sync hwclock to syscock ready for date/time stuff
    util.runCmd("hwclock --utc --hctosys")
    
    try:
        (opts, _) = getopt(sys.argv[1:],
                           "",
                           ["answerfile=",
                            "verbose-answerfile=",
                            "keymap=",
                            "clog="])
    except GetoptError:
        print "This program takes no arguments."
        sys.exit(1)

    # prepare LVM - we need this very early now.
    os.environ['LVM_SYSTEM_DIR'] = '/tmp/lvm'
    if not os.path.exists('/tmp/lvm'):
        os.mkdir('/tmp/lvm')

    clog_fds = []

    results = {}

    for (opt, val) in opts:
        if opt == "--keymap":
            results["keymap"] = val
            xelogging.log("Keymap specified on command-line: %s" % val)
        if opt == "--answerfile":
            answerfile_ui.specifySubUI(ui_package)
            answerfile_ui.specifyAnswerFile(val)
            ui_package = answerfile_ui
        if opt == "--verbose-answerfile":
            answerfile_ui.specifyAnswerFile(val)
            ui_package = answerfile_ui
            xelogging.continuous_logs.append(sys.stdout)
        if opt == "--clog":
            try:
                fd = open(val, "w")
                clog_fds.append(fd)
                xelogging.continuous_logs.append(fd)
            except:
                print "Error adding continuous log %s." % val

    if not results.has_key("keymap"):
        xelogging.log("No keymap specified on command-line.")

    # log the modules that we loaded:
    xelogging.log("All needed modules should now be loaded. We have loaded:")
    util.runCmd("lsmod")

    status = constants.EXIT_OK

    try:
        xelogging.log("Starting user interface")
        ui_package.init_ui(results, False)

        disks = diskutil.getQualifiedDiskList()
        netifs = netutil.getNetifList()

        # make sure we have discovered at least one disk and
        # at lesat one network interface:
        if len(disks) == 0:
            raise RuntimeError, "No disks found on this host."

        if len(netifs) == 0:
            raise RuntimeError, "No network interfaces found on this host."

        # make sure that we have enough disk space:
        xelogging.log("Found disks: %s" % str(disks))
        diskSizes = [diskutil.getDiskDeviceSize(x) for x in disks]
        diskSizesGB = [diskutil.blockSizeToGBSize(x) for x in diskSizes]
        xelogging.log("Disk sizes: %s" % str(diskSizesGB))

        bigdisks = filter(lambda x: x >= constants.min_primary_disk_size,
                          diskSizesGB)
        if bigdisks == []:
            raise RuntimeError, "Not enough disk space to proceed."

        # how much RAM do we have?
        ram_found_mb = hardware.getHostTotalMemoryKB() / 1024
        ram_warning = ram_found_mb < constants.MIN_SYSTEM_RAM_MB
        vt_warning = not hardware.VTSupportEnabled()

        # find existing installations:
        ui_package.showMessageDialog("Please wait", "Checking for existing products...")
        try:
            all_installed_products = product.findXenSourceProducts()
        except Exception, e:
            xelogging.log("A problem occurred whilst scanning for existing installations:")
            ex = sys.exc_info()
            err = str.join("", traceback.format_exception(*ex))
            xelogging.log(err)
            xelogging.log("This is not fatal.  Continuing anyway.")
            all_installed_products = []
        installed_products = filter(lambda p: upgrade.upgradeAvailable(p),
                                    all_installed_products)
        ui_package.clearModelessDialog()
        
        # Generate the UI sequence and populate some default
        # values in backend input.  Note that not all these screens
        # will be displayed as they have conditional to skip them at
        # the start of each function.  In future these conditionals will
        # be moved into the sequence definition and evaluated by the
        # UI dispatcher.
        seq = [ ui_package.welcome_screen,
                ui_package.eula_screen, ]
        if ram_warning or vt_warning:
            seq += [ (ui_package.hardware_warnings, (ram_warning, vt_warning)) ]
        seq += [ (ui_package.get_installation_type, (installed_products, )),
                 ui_package.backup_existing_installation,
                 ui_package.select_primary_disk,
                 ui_package.select_guest_disks,
                 ui_package.confirm_erase_volume_groups,
                 ui_package.select_installation_source,
                 ui_package.get_http_source,
                 ui_package.get_nfs_source,
                 ui_package.verify_source,
                 ui_package.get_root_password,
                 ui_package.get_timezone_region,
                 ui_package.get_timezone_city,
                 ui_package.get_time_configuration_method,
                 ui_package.get_ntp_servers,
                 ui_package.determine_basic_network_config,
                 ui_package.get_name_service_configuration,
                 ui_package.confirm_installation_reinstall
                 ]

        if len(disks) > 1:
            seq += [ ui_package.confirm_installation_multiple_disks ]
        else:
            seq += [ ui_package.confirm_installation_one_disk ]

        uiexit = uicontroller.runUISequence(seq, results)

        if uiexit != uicontroller.EXIT:
            xelogging.log("Starting actual installation")       
            backend.performInstallation(results, ui_package)
            seq = [ ui_package.installation_complete ]
            uicontroller.runUISequence(seq, results)

            xelogging.log("The installation completed successfully.")
        else:
            xelogging.log("The user aborted the installation from within the user interface.")
            status = constants.EXIT_USER_CANCEL
    except Exception, e:
        # first thing to do is to get the traceback and log it:
        ex = sys.exc_info()
        err = str.join("", traceback.format_exception(*ex))
        xelogging.log("INSTALL FAILED.")
        xelogging.log("A fatal exception occurred:")
        xelogging.log(err)

        # now write out logs where possible:
        xelogging.writeLog("/tmp/install-log")

        # collect logs where possible
        xelogging.collectLogs("/tmp")

        # now display a friendly error dialog:
        if str(e) != "":
            ui_package.error_dialog("An error has occurred and the installation must be aborted.  The error was:\n\n%s\n\nPlease refer to your user guide, or %s technical support, for further details." % (str(e), COMPANY_NAME_SHORT))
        else:
            ui_package.error_dialog("An error has occurred and the installation must be aborted.  The details of the error can be found in the installation log, which will be written to /tmp/install-log and /boot/install-log on your hard disk if possible.\n\nPlease refer to your user guide or %s technical support for more details." % COMPANY_NAME_SHORT)

        # clean up the screen
        ui_package.end_ui()

        # and now on the disk if possible:
        if results.has_key('primary-disk'):
            backend.writeLog(results['primary-disk'])

        # close continuous logs:
        for logfd in clog_fds:
            try:
                xelogging.continuous_logs.remove(logfd)
            except:
                pass
            logfd.close()

        # exit with failure status:
        status = constants.EXIT_ERROR

    else:
        xelogging.log("Shutting down user interface")
        ui_package.end_ui()
        
        # close continuous logs:
        for logfd in clog_fds:
            try:
                xelogging.continuous_logs.remove(logfd)
            except:
                pass
            logfd.close()

        # put the log in /tmp:
        xelogging.writeLog("/tmp/install-log")
        xelogging.collectLogs('/tmp')

        # and now on the disk if possible:
        if results.has_key('primary-disk'):
            backend.writeLog(results['primary-disk'])

        assert (status == constants.EXIT_OK or status == constants.EXIT_USER_CANCEL)

    return status

if __name__ == "__main__":
    sys.exit(main())
